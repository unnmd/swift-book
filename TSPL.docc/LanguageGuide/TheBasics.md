# Основы

Работайте с общими видами данных и пишите базовый синтаксис.

Swift предоставляет множество фундаментальных типов данных,
включая `Int` для целых чисел,
`Double` для чисел с плавающей запятой,
`Bool` для булевых значений,
и `String` для текста.
Swift также предоставляет мощные версии трех основных типов коллекций,
`Array`, `Set` и `Dictionary`,
как описано в <doc:CollectionTypes>.

Swift использует переменные для хранения и ссылки на значения по идентификационному 
имени. Swift также широко использует переменные, значения которых не могут быть 
изменены. Эти переменные известны как константы и используются во всем Swift для
обеспечения безопасности кода и ясности намерений при работе с значениями, которые не должны изменяться.

Помимо знакомых типов, Swift представляет продвинутые типы, такие как кортежи. 
Кортежи позволяют вам создавать и передавать группировки значений. Вы можете 
использовать кортеж для возврата нескольких значений из функции как единого 
составного значения.

Swift также вводит опциональные типы, 
которые обрабатывают отсутствие значения. 
Опционалы говорят либо "здесь *есть* значение, 
и оно равно *x*", либо "здесь *нет* значения вообще".

Swift является *типобезопасным* языком, что означает, что язык помогает вам быть
ясным относительно типов значений, с которыми ваш код может работать. 
Если часть вашего кода требует `String`, типовая безопасность предотвращает 
передачу ей по ошибке `Int`. Точно так же типовая безопасность мешает вам 
случайно передавать опциональную `String` в участок кода, который требует 
неопциональную `String`. 
Типовая безопасность помогает вам выявлять и устранять 
ошибки как можно раньше впроцессе разработки.

## Константы и Переменные

Константы и переменные связывают имя
(например, `maximumNumberOfLoginAttempts` или `welcomeMessage`)
со значением определенного типа
(например, число `10` или строка `"Hello"`).
Значение *константы* не может быть изменено после установки,
в то время как *переменная* может быть установлена на другое значение в будущем.

### Объявление Констант и Переменных

Константы и переменные должны быть объявлены перед их использованием.
Константы объявляются с использованием ключевого слова `let`,
а переменные — с использованием ключевого слова `var`.
Вот пример того, как константы и переменные могут быть использованы
для отслеживания количества попыток входа пользователя:

```swift
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
```

<!--
  - test: `constantsAndVariables`

  ```swifttest
  -> let maximumNumberOfLoginAttempts = 10
  -> var currentLoginAttempt = 0
  ```
-->

Этот код можно прочитать следующим образом:

"Объявить новую константу с именем `maximumNumberOfLoginAttempts`
и присвоить ей значение `10`.
Затем объявить новую переменную с именем `currentLoginAttempt`
и присвоить ей начальное значение `0`."

В этом примере
максимальное количество разрешенных попыток входа объявлено как константа,
поскольку максимальное значение никогда не изменяется.
Счетчик текущей попытки входа объявлен как переменная,
потому что это значение должно увеличиваться после каждой неудачной попытки входа.

Если сохраненное значение в вашем коде не будет изменяться,
всегда объявляйте его как константу с использованием ключевого слова `let`.
Используйте переменные только для хранения значений, которые изменяются.

При объявлении константы или переменной
вы можете присвоить ей значение как часть этого объявления,
как показано в приведенных выше примерах.
В качестве альтернативы
вы можете присвоить ей начальное значение позже в программе,
при условии, что гарантируется, что у нее будет значение
перед первым чтением из нее.

```swift
var environment = "development"
let maximumNumberOfLoginAttempts: Int
// Переменной maximumNumberOfLoginAttempts ещё не присвоено значение.

if environment == "development" {
    maximumNumberOfLoginAttempts = 100
} else {
    maximumNumberOfLoginAttempts = 10
}
// Теперь у переменной maximumNumberOfLoginAttempts есть значение и его можно прочитать.
```

<!--
  - test: `constantsWithDeferredInitialization`

  ```swifttest
  -> var environment = "development"
  -> let maximumNumberOfLoginAttempts: Int
  -> if environment == "development" {
         maximumNumberOfLoginAttempts = 100
     } else {
         maximumNumberOfLoginAttempts = 10
     }
  >> print(maxNumberOfLoginAttempts)
  << 100
  ```
-->

В этом примере максимальное количество 
попыток входа является константой, 
и его значение зависит от окружения. 
В среде разработки у него значение 100; 
в любой другой среде его значение равно 10. 
Обе ветви оператора `if` инициализируют `maximumNumberOfLoginAttempts` 
какое-то значение, гарантируя, 
что константе всегда присваивается значение. 
Для получения информации о том, 
как Swift проверяет ваш код 
при установке начального значения, таким образом, 
см. <doc:Declarations#Constant-Declaration>.

Вы можете объявить несколько констант или переменных в одной строке, 
разделяя их запятыми:

```swift
var x = 0.0, y = 0.0, z = 0.0
```

<!--
  - test: `multipleDeclarations`

  ```swifttest
  -> var x = 0.0, y = 0.0, z = 0.0
  >> print(x, y, z)
  << 0.0 0.0 0.0
  ```
-->

### Аннотации Типов

Вы можете предоставить *аннотацию типа* при объявлении константы или переменной,
чтобы явно указать тип значений, которые может хранить константа или переменная.
Напишите аннотацию типа, разместив двоеточие после имени константы или 
переменной, за которым следует пробел, а затем имя типа для использования.

В этом примере предоставлена аннотация типа для переменной с именем `welcomeMessage`,
чтобы указать, что переменная может хранить значения типа `String`:

```swift
var welcomeMessage: String
```

<!--
  - test: `typeAnnotations`

  ```swifttest
  -> var welcomeMessage: String
  ```
-->

Двоеточие в объявлении означает "...типа...", 
поэтому код выше можно прочитать как:

"Объявить переменную с именем `welcomeMessage` типа `String`."

Фраза "типа `String`" означает "может хранить любое значение типа `String`". 
Представьте себе это как описание "типа вещи" (или "вида вещи"), которую можно хранить.

Переменной `welcomeMessage` теперь можно присвоить любое строковое значение без ошибок:

```swift
welcomeMessage = "Hello"
```

<!--
  - test: `typeAnnotations`

  ```swifttest
  -> welcomeMessage = "Hello"
  >> print(welcomeMessage)
  << Hello
  ```
-->

Вы можете определить несколько связанных переменных одного типа в одной строке, 
разделяя их запятыми, с одной аннотацией типа после последнего имени переменной:

```swift
var red, green, blue: Double
```

<!--
  - test: `typeAnnotations`

  ```swifttest
  -> var red, green, blue: Double
  ```
-->

> Примечание: В практике редко требуется написание аннотаций типов. 
> Если вы предоставляете начальное значение для константы или переменной в том 
> месте, где она определена, Swift почти всегда может самостоятельно вывести 
> тип для использования этой константы или переменной, как описано в
> <doc:TheBasics#Безопасность-типов-и-вывод-типов>. В приведенном выше примере 
> `welcomeMessage` не предоставляется начальное значение, поэтому тип переменной
> `welcomeMessage` указывается аннотацией типа, а не выводится из начального значения.

### Именование Констант и Переменных

Имена констант и переменных могут содержать практически любой символ, 
включая символы Unicode:

```swift
let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
```

<!--
  - test: `constantsAndVariables`

  ```swifttest
  -> let π = 3.14159
  -> let 你好 = "你好世界"
  -> let 🐶🐮 = "dogcow"
  ```
-->

Имена констант и переменных не могут содержать пробельные символы, 
математические символы, стрелки, значения юникодных скаляров для личного 
использования, а также символы линий и рамок. 
Они также не могут начинаться с цифры, 
хотя числа могут включаться в других частях имени.

После того как вы объявили константу или переменную определенного типа, 
вы не можете объявить ее снова с тем же именем или изменить ее, 
чтобы хранить значения другого типа. 
Вы также не можете изменить константу на переменную 
или наоборот.

> Примечание: Если вам нужно дать константе или переменной то же имя, что и зарезервированное ключевое слово
> Swift, окружите ключевое слово обратными кавычками (`` ` ``) при использовании его в качестве имени. 
> Однако избегайте использования ключевых слов в качестве имен, если у вас есть альтернативы.

Значение существующей переменной можно изменить на другое значение совместимого типа. 
В этом примере значение `friendlyWelcome` изменяется с 
`"Hello!"` на `"Bonjour!"`:

```swift
var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome теперь "Bonjour!"
```

<!--
  - test: `constantsAndVariables`

  ```swifttest
  -> var friendlyWelcome = "Hello!"
  -> friendlyWelcome = "Bonjour!"
  /> friendlyWelcome is now \"\(friendlyWelcome)\"
  </ friendlyWelcome is now "Bonjour!"
  ```
-->

В отличие от переменной, значение константы не может быть изменено после установки. 
Попытка сделать это вызовет ошибку во время компиляции:

```swift
let languageName = "Swift"
languageName = "Swift++"
// Это ошибка времени компиляции: languageName нельзя изменить.
```

<!--
  - test: `constantsAndVariables_err`

  ```swifttest
  -> let languageName = "Swift"
  -> languageName = "Swift++"
  // This is a compile-time error: languageName cannot be changed.
  !$ error: cannot assign to value: 'languageName' is a 'let' constant
  !! languageName = "Swift++"
  !! ^~~~~~~~~~~~
  !! /tmp/swifttest.swift:1:1: note: change 'let' to 'var' to make it mutable
  !! let languageName = "Swift"
  !! ^~~
  !! var
  ```
-->

### Печать Констант и Переменных

Вы можете напечатать текущее значение константы или переменной с помощью функции `print(_:separator:terminator:)`:

```swift
print(friendlyWelcome)
// Печатает "Bonjour!"
```

<!--
  - test: `constantsAndVariables`

  ```swifttest
  -> print(friendlyWelcome)
  <- Bonjour!
  ```
-->

Функция `print(_:separator:terminator:)` является глобальной функцией, 
которая выводит одно или несколько значений в соответствующий вывод. 
Например, в Xcode функция 
`print(_:separator:terminator:)` выводит результат в 
"консольное" окно Xcode. Параметры `separator` и `terminator` имеют значения по 
умолчанию, поэтому вы можете опустить их при вызове этой функции.
По умолчанию функция завершает строку, 
добавляя перевод строки после печатаемого значения. 
Чтобы вывести значение без перевода строки после него, 
передайте пустуюстроку в качестве аргумента `terminator` — 
например, `print(someValue, terminator: "")`. 
Дополнительную информацию о параметрах со значениями по умолчанию можно найти в 
разделе <doc:Functions#Default-Parameter-Values>.

<!--
  - test: `printingWithoutNewline`

  ```swifttest
  >> let someValue = 10
  -> print(someValue, terminator: "")
  -> print(someValue)
  << 1010
  ```
-->

<!--
  ВОПРОС: я правильно обратился к консоли Xcode здесь? 
  Следует ли упомянуть другие потоки вывода, такие как REPL / песочницы?
-->

<!--
  ПРИМЕЧАНИЕ: это преднамеренно упрощенное описание того, что вы можете сделать с функцией print(). 
  Позже оно будет расширено.
-->

Swift использует *интерполяцию строк* для включения имени константы или переменной
в качестве заполнителя в более длинной строке и для того, чтобы побудить Swift 
заменить его текущим значением этой константы или переменной. Оберните имя в 
круглые скобки и предварительно экранируйте его обратным слешем перед открывающей круглой скобкой:

```swift
print("The current value of friendlyWelcome is \(friendlyWelcome)")
// Prints "The current value of friendlyWelcome is Bonjour!"
```

<!--
  - test: `constantsAndVariables`

  ```swifttest
  -> print("The current value of friendlyWelcome is \(friendlyWelcome)")
  <- The current value of friendlyWelcome is Bonjour!
  ```
-->

> Примечание: Все варианты использования интерполяции строк описаны 
> в разделе <doc:StringsAndCharacters#String-Interpolation>.

## Комментарии

Используйте комментарии для включения неисполняемого текста в ваш код в виде 
заметки или напоминания для себя. 
Комментарии игнорируются компилятором Swift при компиляции вашего кода.

Комментарии в Swift очень похожи на комментарии в C. 
Однострочные комментарии начинаются с двух косых черт (`//`):

```swift
// Это комментарий.
```

<!--
  - test: `comments`

  ```swifttest
  -> // This is a comment.
  ```
-->

Многострочные комментарии начинаются с косой черты, за которой следует звезда (`/*`),
и заканчиваются звездой, за которой следует косая черта (`*/`):

```swift
/* Это также комментарий,
но написанный на нескольких строках. */
```

<!--
  - test: `comments`

  ```swifttest
  -> /* This is also a comment
     but is written over multiple lines. */
  ```
-->

В отличие от многострочных комментариев в C, многострочные комментарии в Swift 
могут быть вложены друг в друга. Вы создаете вложенные комментарии, 
начиная блок многострочного комментария, а затем начиная второй многострочный 
комментарий внутри первого блока. Затем второй блок закрывается, 
за которым следует первый блок:

```swift
/* Это начало первого многострочного комментария.
    /* Это второй, вложенный многострочный комментарий. */
Это конец первого многострочного комментария. */
```

<!--
  - test: `comments`

  ```swifttest
  -> /* This is the start of the first multiline comment.
        /* This is the second, nested multiline comment. */
     This is the end of the first multiline comment. */
  ```
-->

Вложенные многострочные комментарии позволяют вам быстро и легко комментировать 
большие блоки кода, даже если код уже содержит многострочные комментарии.

## Точки с запятой

В отличие от многих других языков программирования, в Swift нет обязательства 
ставить точку с запятой (`;`) после каждого оператора в вашем коде, 
хотя вы можете сделать это, если хотите. 
Однако точки с запятой *обязательны*, 
если вы хотите написать несколько отдельных операторов в одной строке:

```swift
let cat = "🐱"; print(cat)
// Выводит "🐱"
```

<!--
  - test: `semiColons`

  ```swifttest
  -> let cat = "🐱"; print(cat)
  <- 🐱
  ```
-->

## Целые числа

*Целые числа* - это целые числа без дробной части, 
такие как `42` и `-23`. 
Целые числа бывают *знаковыми* (положительные, ноль или отрицательные)
или *беззнаковыми* (положительные или ноль).

Swift предоставляет знаковые и беззнаковые целые числа в формах 8, 16, 32 и 64 бита. 
Эти целые числа следуют конвенции имен, аналогичной C, 
где 8-битное беззнаковое целое число имеет тип `UInt8`, 
а 32-битное знаковое целое число - тип `Int32`. Как и все типы в Swift, 
эти типы целых чисел начинаются с заглавной буквы.

### Границы целых чисел

Вы можете получить доступ к минимальным и максимальным значениям каждого типа 
целого числа с использованием свойств `min` и `max`:

```swift
let minValue = UInt8.min  // minValue равно 0, и имеет тип UInt8
let maxValue = UInt8.max  // maxValue равно 255, и имеет тип UInt8
```

<!--
  - test: `integerBounds`

  ```swifttest
  -> let minValue = UInt8.min  // minValue равно 0, и имеет тип UInt8
  -> let maxValue = UInt8.max  // maxValue равно 255, и имеет тип UInt8
  >> print(minValue, maxValue)
  << 0 255
  ```
-->

Значения этих свойств соответствуют числам с соответствующим размером (например,
`UInt8` в приведенном выше примере) и, следовательно, 
могут использоваться в выражениях вместе с другими значениями того же типа.

### Int

В большинстве случаев вам не нужно выбирать конкретный размер целого числа для 
использования в вашем коде.  Swift предоставляет дополнительный тип целого числа, Int, 
который имеет тот же размер, что и разрядность вашей системы:

- На 32-битной платформе `Int` имеет тот же размер, что и `Int32`.
- На 64-битной платформе `Int` имеет тот же размер, что и `Int64`.

Если вам не нужно работать с конкретным размером целого числа, всегда 
используйте `Int` для целочисленных значений в вашем коде. 
Это способствует согласованности кода и взаимодействию. 
Даже на 32-битных платформах `Int` может хранить любое значение между 
`-2,147,483,648` и `2,147,483,647` и достаточно велико для многих диапазонов целых чисел.

### UInt

Swift также предоставляет беззнаковый тип целого числа, `UInt`, 
который имеет тот же размер, что и разрядность вашей системы:

- На 32-битной платформе `UInt` имеет тот же размер, что и `UInt32`.
- На 64-битной платформе `UInt` имеет тот же размер, что и `UInt64`.

> Примечание: Используйте `UInt` только тогда, когда вам действительно нужен 
> беззнаковый тип целого числа с тем же размером, что и разрядность вашей системы.
> Если это не так, предпочтительнее использовать `Int`, даже когда известно, что
> значения будут неотрицательными. Согласованное использование `Int` для 
> целочисленных значений облегчит взаимодействие с кодом, избежит необходимости 
> конвертировать между различными типами чисел и соответствует выводу типа для 
> целых чисел, как описано в <doc:TheBasics#Безопасность-типов-и-вывод-типов>.

## Дробные числа с плавающей запятой

*Дробные числа с плавающей запятой* представляют собой числа с дробной частью,
такие как `3.14159`, `0.1` и `-273.15`.

Типы дробных чисел могут представлять гораздо более широкий диапазон значений, чем целочисленные типы,
и могут хранить числа, которые намного больше или меньше тех, что могут быть сохранены в `Int`.
Swift предоставляет два знаковых типа дробных чисел:

- `Double` представляет собой 64-битное дробное число.
- `Float` представляет собой 32-битное дробное число.

> Примечание: `Double` имеет точность не менее 15 десятичных знаков,
> в то время как точность `Float` может быть всего 6 десятичных знаков.
> Выбор между типами дробных чисел зависит от характера и диапазона
> значений, с которыми вам нужно работать в вашем коде.
> В ситуациях, где подходит любой из типов, предпочтительнее использовать `Double`.

<!--
  TODO: Явно упомянуть ситуации, когда Float подходит,
  например, при оптимизации размера для коллекций?
-->

<!--
  TODO: упомянуть бесконечность, -бесконечность и т.д.
-->

## Безопасность типов и вывод типов

Swift - *язык со строгой типизацией*.
Язык со строгой типизацией побуждает вас быть ясными относительно
типов значений, с которыми ваш код может работать.
Если часть вашего кода требует `String`, вы не сможете передать в нее `Int` по ошибке.

Поскольку Swift является языком со строгой типизацией,
он выполняет *проверку типов* при компиляции вашего кода
и выдает сообщения об ошибках при несоответствии типов.
Это позволяет вам выявлять и устранять ошибки на ранних этапах разработки.

Проверка типов помогает вам избегать ошибок при работе с различными типами значений.
Однако это не означает, что вы должны указывать тип
каждой константе и переменной, которую вы объявляете.
Если вы не указываете тип значения,
Swift использует *вывод типов*, чтобы определить соответствующий тип.
Вывод типов позволяет компилятору
автоматически выводить тип конкретного выражения при компиляции вашего кода,
просто анализируя предоставленные значения.

Из-за вывода типов Swift требует гораздо меньше объявлений типов,
чем языки, такие как C или Objective-C.
Константы и переменные по-прежнему имеют явные типы,
но большая часть работы по указанию их типов делается за вас.

Вывод типов особенно полезен
при объявлении констант или переменных с начальным значением.
Это часто делается с использованием *литерального значения* (или *литерала*),
присваиваемого константе или переменной в момент ее объявления.
(Литеральное значение - это значение, которое прямо встроено в ваш исходный код,
как `42` и `3.14159` в приведенных ниже примерах.)

Например, если вы присваиваете литеральное значение `42` новой константе,
не указывая при этом тип, Swift вычисляет, что вы хотите,
чтобы константа была типа `Int`,
поскольку вы инициализировали ее числом, похожим на целое:

```swift
let meaningOfLife = 42
// meaningOfLife выводится как тип Int
```

<!--
  - test: `typeInference`

  ```swifttest
  -> let meaningOfLife = 42
  // meaningOfLife is inferred to be of type Int
  >> print(type(of: meaningOfLife))
  << Int
  ```
-->

Точно так же, если вы не указываете тип для литерала с плавающей точкой,
Swift выводит, что вы хотите создать `Double`:

```swift
let pi = 3.14159
// pi выводится как тип Double
```

<!--
  - test: `typeInference`

  ```swifttest
  -> let pi = 3.14159
  // pi is inferred to be of type Double
  >> print(type(of: pi))
  << Double
  ```
-->

Swift всегда выбирает `Double` (а не `Float`)
при выводе типа чисел с плавающей запятой.

Если вы комбинируете литералы целых и дробных чисел в выражении,
тип `Double` будет выведен из контекста:

```swift
let anotherPi = 3 + 0.14159
// anotherPi также выводится как тип Double
```
<!--
  - test: `typeInference`

  ```swifttest
  -> let anotherPi = 3 + 0.14159
  // anotherPi is also inferred to be of type Double
  >> print(type(of: anotherPi))
  << Double
  ```
-->


Литеральное значение `3` не имеет явного типа само по себе,
и поэтому подходящий выходной тип `Double` выводится
из-за присутствия литерала с плавающей точкой в составе сложения.

## Числовые литералы

Целочисленные литералы можно записывать следующим образом:

- *Десятичное* число, без префикса
- *Двоичное* число, с префиксом `0b`
- *Восьмеричное* число, с префиксом `0o`
- *Шестнадцатеричное* число, с префиксом `0x`

Все эти целочисленные литералы имеют десятичное значение `17`:

```swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 в двоичной записи
let octalInteger = 0o21       // 17 в восьмеричной записи
let hexadecimalInteger = 0x11 // 17 в шестнадцатеричной записи
```

<!--
  - test: `numberLiterals`

  ```swifttest
  -> let decimalInteger = 17
  -> let binaryInteger = 0b10001       // 17 in binary notation
  -> let octalInteger = 0o21           // 17 in octal notation
  -> let hexadecimalInteger = 0x11     // 17 in hexadecimal notation
  >> print(binaryInteger, octalInteger, hexadecimalInteger)
  << 17 17 17
  ```
-->

Литералы с плавающей запятой могут быть десятичными (без префикса)
или шестнадцатеричными (с префиксом `0x`).
Они всегда должны иметь число (или шестнадцатеричное число) по обе стороны от десятичной запятой.
Десятичные числа с плавающей запятой также могут иметь необязательный *показатель степени*,
обозначенный заглавной или строчной буквой `e`;
шестнадцатеричные числа с плавающей запятой должны иметь показатель степени,
обозначенный заглавной или строчной буквой `p`.

<!--
  - test: `float-required-vs-optional-exponent-err`

  ```swifttest
  -> let hexWithout = 0x1.5
  !$ error: hexadecimal floating point literal must end with an exponent
  !! let hexWithout = 0x1.5
  !!                       ^
  ```
-->

<!--
  - test: `float-required-vs-optional-exponent`

  ```swifttest
  -> let hexWith = 0x1.5p7
  -> let decimalWithout = 0.5
  -> let decimalWith = 0.5e7
  ```
-->

Для десятичных чисел с показателем степени `x`,
базовое число умножается на 10ˣ:

- `1.25e2` означает 1,25 x 10² или `125.0`.
- `1.25e-2` означает 1,25 x 10⁻² или `0.0125`.

Для шестнадцатеричных чисел с показателем степени `x`,
базовое число умножается на 2ˣ:

- `0xFp2` означает 15 x 2² или `60.0`.
- `0xFp-2` означает 15 x 2⁻² или `3.75`.

Все эти литералы с плавающей запятой имеют десятичное значение `12.1875`:

```swift
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```

<!--
  - test: `numberLiterals`

  ```swifttest
  -> let decimalDouble = 12.1875
  -> let exponentDouble = 1.21875e1
  -> let hexadecimalDouble = 0xC.3p0
  ```
-->

Числовые литералы могут содержать дополнительное форматирование, чтобы их было легче читать.
Как целые числа, так и числа с плавающей запятой могут быть дополнены дополнительными нулями
и могут содержать символы подчеркивания для повышения читаемости.
Ни один из этих типов форматирования не влияет на базовое значение литерала:

```swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```

<!--
  - test: `numberLiterals`

  ```swifttest
  -> let paddedDouble = 000123.456
  -> let oneMillion = 1_000_000
  -> let justOverOneMillion = 1_000_000.000_000_1
  ```
-->

## Преобразование числовых типов

Используйте тип `Int` для всех целочисленных констант и переменных в вашем коде,
даже если известно, что они неотрицательны.
Использование типа целого числа по умолчанию в повседневных ситуациях означает, что
целочисленные константы и переменные немедленно взаимосовместимы в вашем коде
и будут соответствовать выведенному типу для целочисленных литералов.

Используйте другие целочисленные типы только тогда, когда они действительно необходимы для задачи,
из-за явно определенных данных из внешнего источника,
или для выполнения оптимизации производительности, использования памяти или других необходимых оптимизаций.
Использование явно определенных типов в этих ситуациях
помогает выявить любые случайные переполнения значений
и неявно документирует характер используемых данных.

### Преобразование целых чисел

Диапазон чисел, которые можно хранить в константе или переменной целого типа,
различен для каждого числового типа.
Константа или переменная типа `Int8` может хранить числа от `-128` до `127`,
в то время как константа или переменная типа `UInt8` может хранить числа от `0` до `255`.
Число, которое не помещается в константу или переменную с определенным размером целого числа,
сообщается как ошибка при компиляции вашего кода:

```swift
let cannotBeNegative: UInt8 = -1
// UInt8 не может хранить отрицательные числа, и поэтому это вызовет ошибку
let tooBig: Int8 = Int8.max + 1
// Int8 не может хранить число, превышающее его максимальное значение,
// и поэтому это также вызовет ошибку
```

<!--
  - test: `constantsAndVariablesOverflowError`

  ```swifttest
  -> let cannotBeNegative: UInt8 = -1
  // UInt8 can't store negative numbers, and so this will report an error
  -> let tooBig: Int8 = Int8.max + 1
  // Int8 can't store a number larger than its maximum value,
  // and so this will also report an error
  !! /tmp/swifttest.swift:2:29: error: arithmetic operation '127 + 1' (on type 'Int8') results in an overflow
  !! let tooBig: Int8 = Int8.max + 1
  !!                    ~~~~~~~~ ^ ~
  !! /tmp/swifttest.swift:1:31: error: negative integer '-1' overflows when stored into unsigned type 'UInt8'
  !! let cannotBeNegative: UInt8 = -1
  !!                                ^
  ```
-->

Поскольку каждый числовой тип может хранить различный диапазон значений,
вы должны явно выбирать преобразование числового типа в каждом конкретном случае.
Этот подход предотвращает скрытые ошибки преобразования
и помогает сделать намерения по преобразованию типов явными в вашем коде.

Чтобы преобразовать один конкретный числовой тип в другой,
вы инициализируете новое число нужного типа существующим значением.
В приведенном ниже примере
константа `twoThousand` имеет тип `UInt16`,
тогда как константа `one` имеет тип `UInt8`.
Их нельзя складывать напрямую,
потому что они не одного и того же типа.
Вместо этого в этом примере вызывается `UInt16(one)` для создания
нового `UInt16`, инициализированного значением `one`,
и это значение используется вместо исходного:

```swift
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```

<!--
  - test: `typeConversion`

  ```swifttest
  -> let twoThousand: UInt16 = 2_000
  -> let one: UInt8 = 1
  -> let twoThousandAndOne = twoThousand + UInt16(one)
  >> print(twoThousandAndOne)
  << 2001
  ```
-->

Поскольку обе стороны сложения теперь имеют тип `UInt16`,
сложение разрешено.
Итоговая константа (`twoThousandAndOne`) выводится как тип `UInt16`,
потому что это сумма двух значений `UInt16`.

`SomeType(ofInitialValue)` - это типичный способ вызова инициализатора типа Swift
и передачи начального значения.
Внутри `UInt16` есть инициализатор, принимающий значение типа `UInt8`,
и поэтому этот инициализатор используется для создания нового `UInt16` из существующего `UInt8`.
Здесь вы не можете передавать *любой* тип, однако ---
это должен быть тип, для которого `UInt16` предоставляет инициализатор.
Расширение существующих типов для предоставления инициализаторов, принимающих новые типы
(включая ваши собственные определения типов)
рассматривается в разделе <doc:Extensions>.

### Преобразование между целыми и числами с плавающей точкой

Преобразования между целыми и числами с плавающей точкой должны быть сделаны явно:

```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi равно 3.14159 и выводится как тип Double
```

<!--
  - test: `typeConversion`

  ```swifttest
  -> let three = 3
  -> let pointOneFourOneFiveNine = 0.14159
  -> let pi = Double(three) + pointOneFourOneFiveNine
  /> pi equals \(pi), and is inferred to be of type Double
  </ pi equals 3.14159, and is inferred to be of type Double
  ```
-->

Здесь значение константы `three` используется для создания нового значения типа `Double`,
чтобы обе стороны сложения имели одинаковый тип.
Без этого преобразования сложение не было бы разрешено.

Преобразование чисел с плавающей точкой в целые числа также должно быть явным.
Целочисленный тип можно инициализировать значением типа `Double` или `Float`:

```swift
let integerPi = Int(pi)
// integerPi равно 3 и выводится как тип Int
```

<!--
  - test: `typeConversion`

  ```swifttest
  -> let integerPi = Int(pi)
  /> integerPi равно \(integerPi) и выводится как тип Int
  </ integerPi равно 3 и выводится как тип Int
  ```
-->

Значения с плавающей точкой всегда усекаются при использовании для инициализации нового целочисленного значения таким образом.
Это означает, что `4.75` становится `4`, а `-3.9` становится `-3`.

> Примечание: Правила для объединения числовых констант и переменных отличаются от
> правил для числовых литералов.
> Литеральное значение `3` можно добавить непосредственно к литеральному значению `0.14159`,
> потому что числовые литералы сами по себе не имеют явного типа.
> Их тип выводится только в тот момент, когда они оцениваются компилятором.

<!--
  ПРИМЕЧАНИЕ: Этот раздел о явных преобразованиях может быть включен в раздел "Операторы".
  Однако я считаю, что он более уместен здесь,
  и помогает подчеркнуть сообщение "просто используйте Int".
-->

## Псевдонимы типов

*Псевдонимы типов* определяют альтернативное имя для существующего типа.
Псевдонимы типов определяются с использованием ключевого слова `typealias`.

Псевдонимы типов полезны, когда вы хотите ссылаться на существующий тип
более подходящим контекстным именем, например, 
при работе с данными определенного размера из внешнего источника:

```swift
typealias AudioSample = UInt16
```

<!--
  - test: `typeAliases`

  ```swifttest
  -> typealias AudioSample = UInt16
  ```
-->

После определения псевдонима типа
вы можете использовать его везде, где могли бы использовать оригинальное имя:

```swift
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound теперь равно 0
```

<!--
  - test: `typeAliases`

  ```swifttest
  -> var maxAmplitudeFound = AudioSample.min
  /> maxAmplitudeFound теперь равно  \(maxAmplitudeFound)
  </ maxAmplitudeFound теперь равно 0
  ```
-->

Здесь `AudioSample` определен как псевдоним для `UInt16`.
Поскольку это псевдоним,
вызов `AudioSample.min` фактически вызывает `UInt16.min`,
что предоставляет начальное значение `0` для переменной `maxAmplitudeFound`.

## Логические значения

Swift имеет базовый *логический* тип, называемый `Bool`.
Логические значения называются *логическими*,
потому что они могут быть только истинными или ложными.
Swift предоставляет два константных значения типа `Bool`,
`true` и `false`:

```swift
let orangesAreOrange = true
let turnipsAreDelicious = false
```

<!--
  - test: `booleans`

  ```swifttest
  -> let orangesAreOrange = true
  -> let turnipsAreDelicious = false
  ```
-->

Типы `orangesAreOrange` и `turnipsAreDelicious`
были выведены как `Bool` из-за того, что
они были инициализированы логическими литеральными значениями.
Как и в случае с `Int` и `Double` выше,
вам не нужно объявлять константы или переменные как `Bool`,
если вы устанавливаете их в `true` или `false` сразу при создании.
Вывод типа помогает сделать код на Swift более лаконичным и читаемым,
когда константы или переменные инициализируются значениями, тип которых уже известен.

Логические значения особенно полезны при работе с условными операторами,
такими как оператор `if`:

```swift
if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible.")
}
// Вывод: "Eww, turnips are horrible."
```

<!--
  - test: `booleans`

  ```swifttest
  -> if turnipsAreDelicious {
        print("Mmm, tasty turnips!")
     } else {
        print("Eww, turnips are horrible.")
     }
  <- Eww, turnips are horrible.
  ```
-->

Условные операторы, такие как оператор `if`, рассматриваются более подробно в разделе <doc:ControlFlow>.

Типовая безопасность Swift предотвращает использование не логических значений вместо `Bool`.
В следующем примере будет сообщена ошибка на этапе компиляции:

```swift
let i = 1
if i {
    // этот пример не будет компилироваться и вызовет ошибку
}
```

<!--
  - test: `booleansNotBoolean`

  ```swifttest
  -> let i = 1
  -> if i {
        // этот пример не будет компилироваться и вызовет ошибку
     }
  !$ ошибка: тип 'Int' нельзя использовать как логическое значение; вместо этого используйте проверку на '!= 0'.
  !! if i {
  !!   ^
  !! ( != 0)
  ```
-->

Однако альтернативный пример ниже является допустимым:

```swift
let i = 1
if i != 0 {
    // этот пример будет компилироваться
}
```

<!--
  - test: `booleansIsBoolean`

  ```swifttest
  -> let i = 1
  -> if i == 1 {
        // этот пример будет компилироваться
     }
  ```
-->

Результат сравнения `i == 1` имеет тип `Bool`,
и поэтому этот второй пример успешно проходит проверку типов.
Сравнения, такие как `i == 1`, рассматриваются в разделе <doc:BasicOperators>.

Как и в других примерах безопасности типов в Swift,
этот подход предотвращает случайные ошибки
и обеспечивает ясность намерений в конкретном участке кода.

## Кортежи

*Кортежи* группируют несколько значений в единое сложное значение.
Значения внутри кортежа могут иметь любой тип
и не обязаны быть одного и того же типа.

В этом примере `(404, "Not Found")` - это кортеж, описывающий *код состояния HTTP*.
Код состояния HTTP - это специальное значение, возвращаемое веб-сервером при запросе веб-страницы.
Код состояния `404 Not Found` возвращается, если вы запрашиваете веб-страницу, которой не существует.

```swift
let http404Error = (404, "Not Found")
// http404Error имеет тип (Int, String) и равен (404, "Not Found")
```

<!--
  - test: `tuples`

  ```swifttest
  -> let http404Error = (404, "Not Found")
  /> http404Error имеет тип (Int, String) и равен (\(http404Error.0), \"\(http404Error.1)\")
  </ http404Error имеет тип (Int, String) и равен (404, "Not Found")
  ```
-->

Кортеж (404, "Not Found") группирует вместе Int и String, 
чтобы придать коду состояния HTTP два отдельных значения:
число и понятное человеку описание. 
Это можно описать как “кортеж типа (Int, String)”.

Вы можете создавать кортежи из любой перестановки типов, 
и они могут содержать столько различных типов, сколько вам нужно. 
Ничто не мешает вам иметь кортеж типа `(Int, Int, Int)`, 
`(String, Bool)` или любую другую перестановку, 
которая вам нужна.

Вы можете *раскладывать* содержимое кортежа на отдельные константы или 
переменные и затем использовать их как обычно:

```swift
let (statusCode, statusMessage) = http404Error
print("Код состояния \(statusCode)")
// Выводит "Код состояния 404"
print("Сообщение состояния \(statusMessage)")
// Выводит "Сообщение состояния Not Found"
```

<!--
  - test: `tuples`

  ```swifttest
  -> let (statusCode, statusMessage) = http404Error
  -> print("The status code is \(statusCode)")
  <- The status code is 404
  -> print("The status message is \(statusMessage)")
  <- The status message is Not Found
  ```
-->

Если вам нужны только некоторые значения из кортежа, 
вы можете игнорировать части кортежа, 
поставив подчеркивание (`_`) при разложении кортежа:

```swift
let (justTheStatusCode, _) = http404Error
print("Код состояния \(justTheStatusCode)")
// Выводит "Код состояния 404"
```

<!--
  - test: `tuples`

  ```swifttest
  -> let (justTheStatusCode, _) = http404Error
  -> print("The status code is \(justTheStatusCode)")
  <- The status code is 404
  ```
-->

В альтернативе, можно получить доступ к отдельным 
значениям элементов в кортеже, используя индексы, начинающиеся с нуля:

```swift
print("Код состояния \(http404Error.0)")
// Выводит "Код состояния 404"
print("Сообщение состояния \(http404Error.1)")
// Выводит "Сообщение состояния Not Found"
```

<!--
  - test: `tuples`

  ```swifttest
  -> print("The status code is \(http404Error.0)")
  <- The status code is 404
  -> print("The status message is \(http404Error.1)")
  <- The status message is Not Found
  ```
-->

Вы можете называть отдельные элементы в кортеже при его определении:

```swift
let http200Status = (statusCode: 200, description: "OK")
```

<!--
  - test: `tuples`

  ```swifttest
  -> let http200Status = (statusCode: 200, description: "OK")
  ```
-->

Если вы называете элементы в кортеже, 
вы можете использовать имена элементов для доступа к их значениям:

```swift
print("Код состояния \(http200Status.statusCode)")
// Выводит "Код состояния 200"
print("Сообщение состояния \(http200Status.description)")
// Выводит "Сообщение состояния OK"
```

<!--
  - test: `tuples`

  ```swifttest
  -> print("The status code is \(http200Status.statusCode)")
  <- The status code is 200
  -> print("The status message is \(http200Status.description)")
  <- The status message is OK
  ```
-->

Кортежи особенно полезны в качестве возвращаемых значений функций. 
Функция, которая пытается получить веб-страницу, 
может вернуть тип кортежа `(Int, String)`, 
чтобы описать успешность или неудачу получения страницы. 
Возвращая кортеж с двумя различными значениями, 
каждое из разных типов, функция предоставляет более полезную информацию о своем результате, 
чем если бы она могла вернуть только одно значение одного типа. 
Дополнительные сведения можно найти в разделе <doc:Functions#Functions-with-Multiple-Return-Values>.

> Примечание: Кортежи удобны для простых групп связанных значений. 
> Они не подходят для создания сложных структур данных. 
> Если ваша структура данных, вероятно, будет более сложной, 
> моделируйте ее как класс или структуру, а не как кортеж. 
> Дополнительные сведения можно найти в разделе <doc:ClassesAndStructures>.

## Опционалы

Опционалы используются в ситуациях, когда значение может отсутствовать. 
Опционал представляет две возможности: либо *есть* значение указанного типа, 
и вы можете извлечь опционал, 
чтобы получить это значение, 
либо *нет* значения вообще.

Как пример значения, которое может отсутствовать, 
у типа `Int` в Swift есть инициализатор, 
который пытается преобразовать значение `String` в значение типа `Int`. 
Однако только некоторые строки можно преобразовать в целые числа. 
Строка `"123"` может быть преобразована в числовое значение `123`, 
но строка `"hello, world"` не имеет соответствующего числового значения. 
В приведенном ниже примере используется инициализатор для попытки преобразования `String` в `Int`:

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// Тип convertedNumber - "optional Int"
```

<!--
  - test: `optionals`

  ```swifttest
  -> let possibleNumber = "123"
  -> let convertedNumber = Int(possibleNumber)
  // convertedNumber is inferred to be of type "Int?", or "optional Int"
  >> print(type(of: convertedNumber))
  << Optional<Int>
  ```
-->

Поскольку инициализатор в приведенном выше коде может завершиться неудачей, 
он возвращает *опциональное* `Int`, а не `Int`.

Чтобы указать тип опционала, после имени типа, который он содержит, 
пишется вопросительный знак (`?`) --- 
например, тип опционального `Int` - это `Int?`. 
Опциональное `Int` всегда содержит либо некоторое значение `Int`, 
либо совсем ничего. 
В нем не может содержаться ничего другого, например, 
значение `Bool` или `String`.

### nil

Вы устанавливаете переменную опционала в состояние без значения, 
присваивая ей специальное значение `nil`:

```swift
var serverResponseCode: Int? = 404
// serverResponseCode содержит фактическое значение Int 404
serverResponseCode = nil
// Теперь serverResponseCode не содержит значения
```

<!--
  - test: `optionals`

  ```swifttest
  -> var serverResponseCode: Int? = 404
  /> serverResponseCode contains an actual Int value of \(serverResponseCode!)
  </ serverResponseCode contains an actual Int value of 404
  -> serverResponseCode = nil
  // serverResponseCode now contains no value
  ```
-->

Если вы определяете переменную опционала без предоставления значения по умолчанию,
переменная автоматически устанавливается в `nil`:

```swift
var surveyAnswer: String?
// surveyAnswer автоматически устанавливается в nil
```

<!--
  - test: `optionals`

  ```swifttest
  -> var surveyAnswer: String?
  // surveyAnswer is automatically set to nil
  ```
-->

Вы можете использовать оператор `if`, чтобы определить, 
содержит ли опционал значение, сравнивая его с `nil`. 
Это сравнение выполняется с использованием оператора «равно» (`==`) 
или оператора «не равно» (`!=`).

Если опционал содержит значение, он считается «не равным» `nil`:

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)

if convertedNumber != nil {
    print("convertedNumber содержит какое-то целочисленное значение.")
}
// Выводит "convertedNumber содержит какое-то целочисленное значение."
```

<!--
  - test: `optionals`

  ```swifttest
  -> if convertedNumber != nil {
        print("convertedNumber содержит какое-то целочисленное значение.")
     }
  <- convertedNumber содержит какое-то целочисленное значение.
  ```
-->

Вы не можете использовать `nil` с неопциональными константами или переменными.
Если константа или переменная в вашем коде должна работать с отсутствием 
значения в определенных условиях, объявите ее в виде опционального значения
соответствующего типа. 
Константа или переменная, объявленная как неопциональное 
значение, гарантированно никогда не содержит значения `nil`. 
Если вы попытаетесь присвоить `nil` неопциональному значению, 
вы получите ошибку на этапе компиляции.

Это разделение на опциональные и неопциональные значения 
позволяет явно обозначить, какая информация может отсутствовать, 
и упрощает написание кода, обрабатывающего отсутствующие значения. 
Вы не можете случайно обрабатывать опционал так, 
как если бы он был неопционалом, потому что такая ошибка приведет к ошибке 
на этапе компиляции. После извлечения значения, ни один из другого кода, 
работающего с этим значением, не должен проверять `nil`, 
поэтому нет необходимости многократно проверять одно и то же значение 
в различных частях вашего кода.

При доступе к опциональному значению ваш код всегда обрабатывает как случай с `nil`, 
так и без `nil`. 
Существует несколько вариантов действий, 
когда значение отсутствует, как описано в следующих разделах:

- Пропустить код, который выполняет операции с значением, когда оно `nil`.

- Распространить значение `nil`, 
  возвращая `nil` или используя оператор `?.`, 
  описанный в разделе <doc:OptionalChaining>.

- Предоставить значение по умолчанию с использованием оператора `??`.

- Остановить выполнение программы с использованием оператора `!`.

> Примечание:
> В Objective-C `nil` - это указатель на несуществующий объект. 
> В Swift `nil` не является указателем - это отсутствие значения определенного типа.
> Опционалы любого типа могут быть установлены в `nil`, не только для объектных типов.

### Привязка опционала

Привязка опционала используется для определения, содержит ли опционал значение, 
и если да, чтобы сделать это значение доступным в виде временной константы или 
переменной. 
Привязка опционала может использоваться с операторами `if`, 
`guard` и `while` для проверки значения внутри опционала и извлечения этого 
значения в константу или переменную в рамках одного действия. 
Дополнительные сведения о операторах `if`, `guard` и `while` можно найти 
в разделе <doc:ControlFlow>.

Пример использования привязки опционала в операторе `if`:

```swift
if let <#constantName#> = <#someOptional#> {
   <#statements#>
}
```

Вы можете переписать пример с `possibleNumber` из 
раздела <doc:TheBasics#Опционалы>, 
используя привязку опционала вместо принудительного развертывания:

```swift
if let actualNumber = Int(possibleNumber) {
    print("Строка \"\(possibleNumber)\" имеет целочисленное значение \(actualNumber)")
} else {
    print("Строку \"\(possibleNumber)\" нельзя преобразовать в целое число")
}
// Выводит "Строка "123" имеет целочисленное значение 123"
```

<!--
  - test: `optionals`

  ```swifttest
  -> if let actualNumber = Int(possibleNumber) {
        print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
     } else {
        print("The string \"\(possibleNumber)\" couldn't be converted to an integer")
     }
  <- The string "123" has an integer value of 123
  ```
-->

Этот код можно прочитать так:

"Если опционал `Int`, возвращаемый `Int(possibleNumber)`, содержит значение, 
то установит новую константу с именем `actualNumber` в значение, содержащееся в опционале."

Если преобразование прошло успешно, 
константа `actualNumber` становится 
доступной для использования внутри первой ветви оператора `if`. 
Она уже была инициализирована значением, содержащимся в опционале, 
и имеет соответствующий неопциональный тип. 
В данном случае тип `possibleNumber` - это `Int?`, 
поэтому тип `actualNumber` - это `Int`.

Если вам не нужно ссылаться на исходный опциональный объект 
после доступа к его значению, вы можете использовать то же 
самое имя для новой константы или переменной:

```swift
let myNumber = Int(possibleNumber)
// Здесь myNumber является опциональным целым числом
if let myNumber = myNumber {
    // Здесь myNumber является неопциональным целым числом
    print("Моё число - \(myNumber)")
}
// Выводит "Моё число - 123"
```

<!--
  - test: `optionals`

  ```swifttest
  -> let myNumber = Int(possibleNumber)
  // Здесь myNumber является опциональным целым числом
  -> if let myNumber = myNumber {
         // Здесь myNumber является неопциональным целым числом
         print("Моё число - \(myNumber)")
     }
  <- Моё число - 123
  ```
-->

Этот код начинается с проверки того, содержит ли `myNumber` значение, так же, 
как и код в предыдущем примере. Если `myNumber` содержит значение, 
значение новой константы с именем `myNumber`, 
то устанавливается в это значение.
Внутри тела оператора `if` запись `myNumber` обозначает эту новую неопциональную
константу. 
Запись `myNumber` до или после оператора `if` обозначает исходную 
опциональную константу целого числа.

Поскольку такой код весьма распространен, 
можно использовать более короткую запись для развертывания опционального значения:
написать только имя константы или переменной, которую вы разворачиваете. 
Новая развернутая константа или переменная неявно использует то же имя, 
что и опциональное значение.

```swift
if let myNumber {
    print("Моё число - \(myNumber)")
}
// Выводит "Моё число - 123"
```

<!--
  - test: `optionals`

  ```swifttest
  -> if let myNumber {
         print("Моё число - \(myNumber)")
     }
  <- Моё число - 123
  ```
-->

Вы можете использовать как константы, 
так и переменные с привязкой опционала. 
Если вы хотите изменить значение `myNumber` внутри первой ветви оператора `if`, 
вы можете написать `if var myNumber` вместо этого, 
и значение, содержащееся в опционале, 
будет доступно в виде переменной, 
а не константы. 
Изменения, внесенные в `myNumber` внутри тела оператора `if`, 
применяются только к этой локальной переменной, 
а *не* к исходному опциональному значению. 

Вы можете включить в один оператор `if` 
столько привязок опционала и логических 
условий, сколько вам нужно, разделяя их запятыми. 
Если хотя бы одно из значений в привязках опционала равно `nil` или любое 
логическое условие оценивается как `false`, условие всего оператора `if` 
считается ложным. 
Следующие операторы `if` эквивалентны:

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Выводит "4 < 42 < 100"

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Выводит "4 < 42 < 100"
```

<!--
  - test: `multipleOptionalBindings`

  ```swifttest
  -> if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
        print("\(firstNumber) < \(secondNumber) < 100")
     }
  <- 4 < 42 < 100

  -> if let firstNumber = Int("4") {
         if let secondNumber = Int("42") {
             if firstNumber < secondNumber && secondNumber < 100 {
                 print("\(firstNumber) < \(secondNumber) < 100")
             }
         }
     }
  <- 4 < 42 < 100
  ```
-->

<!--
  Приведенный выше пример использует несколько привязок опционала,
  чтобы показать, что их может быть больше одной,
  и чтобы показать поведение короткого замыкания.
  В нем также используются несколько логических условий,
  чтобы показать, что лучше объединять логически связанные условия
  с использованием оператора && вместо запятой.
-->

Константы и переменные, созданные с использованием привязки опционала в 
операторе `if`, доступны только внутри тела оператора `if`. 
В отличие от этого константы и переменные, 
созданные с использованием оператора `guard`, доступны в строках кода, следующих 
за оператором `guard`, как описано в разделе <doc:ControlFlow#Early-Exit>.

### Предоставление значений по умолчанию

Еще один способ обработки отсутствующего значения - предоставление значения по 
умолчанию с использованием оператора объединения по нулю (`??`). 
Если опционал слева от `??` не является `nil`, 
то это значение извлекается и используется. 
В противном случае используется значение справа от `??`. 
Например, 
приведенный ниже код приветствует человека по имени, если имя указано, 
и использует обобщенное приветствие, когда имя равно `nil`.

```swift
let name: String? = nil
let greeting = "Hello, " + (name ?? "friend") + "!"
print(greeting)
// Выводит "Hello, friend!"
```

<!--
.. testcode:: optionalFallback

   ```swifttest
   -> let name: String? = nil
   -> let greeting = "Hello, " + (name ?? "friend") + "!"
   -> print(greeting)
   <- Hello, friend!
   ```
-->

Дополнительную информацию о использовании `??` для предоставления значения 
по умолчанию см. в разделе <doc:BasicOperators#Nil-Coalescing-Operator>.

### Принудительное извлечение

Когда `nil` представляет собой неустранимую ошибку, 
такую как ошибка программиста или поврежденное состояние, 
можно получить доступ к базовому значению, 
добавив восклицательный знак (`!`) в конец имени опционала. 
Это известно как *принудительное извлечение* значения опционала. 
Когда вы принудительно извлекаете значение, не являющееся `nil`, 
результатом является его извлеченное значение. 
Принудительное извлечение значения `nil` вызывает ошибку времени выполнения.

Символ `!` является, по сути, более короткой записью [`fatalError(_:file:line:)`][].
Например, приведенный ниже код показывает два эквивалентных подхода:

[`fatalError(_:file:line:)`]: https://developer.apple.com/documentation/swift/fatalerror(_:file:line:)

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)

let number = convertedNumber!

guard let number = convertedNumber else {
    fatalError("The number was invalid")
}
```

Обе версии кода выше зависят от того, 
что `convertedNumber` всегда содержит значение. 
Запись этого требования в коде с использованием 
любого из приведенных выше подходов позволяет 
вашему коду проверять, что требование выполняется на этапе выполнения.

Дополнительную информацию о обеспечении требований к 
данным и проверке предположений на этапе выполнения 
см. в разделе <doc:TheBasics#Утверждения-и-предусловия>.

### Неявно извлеченные опционалы

Как описано выше, опционалы указывают, что константа или переменная может иметь
«нет значения». Опционалы могут быть проверены с использованием оператора `if`, 
чтобы увидеть, существует ли значение, и могут быть условно распакованы с 
использованием привязки опционала для доступа к значению опционала, 
если оно существует.

Иногда из структуры программы ясно, что опционал *всегда* будет содержать 
значение после того, как это значение будет установлено в первый раз. 
В этих случаях полезно избавиться от необходимости проверки и распаковки значения
опционала при каждом его доступе, потому что можно безопасно предположить, 
что значение всегда существует.

Такие опционалы определяются как *неявно извлеченные опционалы*. Вы создаете 
неявно извлеченный опционал, поместив восклицательный знак (`String!`) вместо
вопросительного знака (`String?`) после типа, который вы хотите сделать опциональным. 
Вместо того чтобы помещать восклицательный знак после имени опционала при его
использовании, вы помещаете восклицательный знак после типа опционала при его объявлении.

Неявно извлеченные опционалы полезны, когда значение опционала подтверждается 
наличием сразу после того, как опционал впервые определен, и можно определенно
предположить, что оно существует на любом этапе дальнейшего выполнения.
Основное использование неявно распакованных опционалов в Swift - во время инициализации класса, как описано 
в разделе <doc:AutomaticReferenceCounting#Unowned-References-and-Implicitly-Unwrapped-Optional-Properties>.

Не используйте неявно извлеченный опционал, если есть возможность того, 
что переменная станет равной `nil` позже. 
Всегда используйте обычный тип опционала, если вам нужно проверить наличие 
значения `nil` в течение времени жизни переменной.

Неявно извлеченный опционал - это обычный опционал на уровне реализации, 
но также может использоваться как обычное значение без необходимости 
распаковывать значение опционала при каждом доступе. 
В следующем примере показано различие в поведении между опциональной строкой и 
неявно распакованной опциональной строкой при доступе к их упакованному значению 
как явному `String`:

```swift
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // Требуется явное извлечение

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // Автоматическое извлечение
```

<!--
  - test: `implicitlyUnwrappedOptionals`

  ```swifttest
  -> let possibleString: String? = "An optional string."
  -> let forcedString: String = possibleString! // требуется восклицательный знак

  -> let assumedString: String! = "An implicitly unwrapped optional string."
  -> let implicitString: String = assumedString // восклицательный знак не требуется
  ```
-->

Вы можете рассматривать неявно развернутый опционал как разрешение для опционала
быть принудительно развернутым, если это необходимо. 
Когда вы используете значение неявно извлеченного опционала, 
Swift сначала пытается использовать его как обычное опциональное значение; 
если его нельзя использовать как опционал, Swift принудительно извлекает 
значение. 
В приведенном выше коде опциональное значение `assumedString` 
принудительно извлекается перед присвоением его значения `implicitString`, 
потому что `implicitString` имеет явный, 
неопциональный тип `String`. 
В коде ниже `optionalString` не имеет явного типа, 
поэтому это обычный опционал.

```swift
let optionalString = assumedString
// Тип optionalString - "String?", и assumedString не принудительно развёрнут.
```

<!--
  - test: `implicitlyUnwrappedOptionals`

  ```swifttest
  -> let optionalString = assumedString
  // Тип optionalString - "String?", и assumedString не принудительно развёрнут.
  >> print(type(of: optionalString))
  << Optional<String>
  ```
-->

Если неявно извлеченный опционал равен `nil`, и вы пытаетесь получить доступ к его извлеченому значению,
вы вызовете ошибку времени выполнения.
Результат будет таким же, как если бы вы написали восклицательный знак,
принудительно извелекая обычный опционал, который не содержит значения.

Вы можете проверить, является ли неявно извлеченный опционал `nil`,
так же, как и обычный опционал:

```swift
if assumedString != nil {
    print(assumedString!)
}
// Вывод: "An implicitly unwrapped optional string."
```

<!--
  - test: `implicitlyUnwrappedOptionals`

  ```swifttest
  -> if assumedString != nil {
        print(assumedString!)
     }
  <- An implicitly unwrapped optional string.
  ```
-->

Также можно использовать неявно извлеченный опционал с опциональным связыванием,
чтобы проверить и развернуть его значение в единственном выражении:

```swift
if let definiteString = assumedString {
    print(definiteString)
}
// Вывод: "An implicitly unwrapped optional string."
```

<!--
  - test: `implicitlyUnwrappedOptionals`

  ```swifttest
  -> if let definiteString = assumedString {
        print(definiteString)
     }
  <- An implicitly unwrapped optional string.
  ```
-->

## Обработка ошибок

Вы используете *обработку ошибок* для реагирования на условия ошибок, 
которые ваша программа может встретить во время выполнения.

В отличие от опционалов, 
которые могут использовать наличие или отсутствие значения для передачи 
успешного или неудачного выполнения функции, 
обработка ошибок позволяет вам определить основную причину ошибки и, 
при необходимости, передавать ошибку в другую часть вашей программы.

Когда функция сталкивается с условием ошибки, она *вызывает* ошибку. 
Затем вызывающая функция может *перехватить* ошибку и соответственно отреагировать.

```swift
func canThrowAnError() throws {
    // Эта функция может вызвать ошибку или не вызвать
}
```

<!--
  - test: `errorHandling`

  ```swifttest
  >> enum SimpleError: Error {
  >>    case someError
  >> }
  >> let condition = true
  -> func canThrowAnError() throws {
        // Эта функция может вызвать ошибку или не вызвать
  >>    if condition {
  >>       throw SimpleError.someError
  >>    }
     }
  ```
-->

Функция указывает, что она может вызвать ошибку, включив ключевое слово `throws`
в своем объявлении. 
При вызове функции, которая может вызвать ошибку, вы добавляете ключевое слово 
`try` перед выражением.

Swift автоматически передает ошибки из их текущей области видимости до тех пор, 
пока они не будут обработаны в блоке `catch`.

```swift
do {
    try canThrowAnError()
    // Ошибки не возникло
} catch {
    // Была вызвана ошибка
}
```

<!--
  - test: `errorHandling`

  ```swifttest
  -> do {
  ->    try canThrowAnError()
  >>    print("No Error")
  ->    // Ошибки не возникло
  -> } catch {
  >>    print("Error")
  ->    // Была вызвана ошибка
  -> }
  << Error
  ```
-->

Оператор `do` создает новую область видимости, что позволяет ошибкам 
передаваться в один или несколько блоков `catch`.

Вот пример того, как обработка ошибок может быть использована для реагирования 
на различные условия ошибок:

```swift
func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```

<!--
  - test: `errorHandlingTwo`

  ```swifttest
  >> enum SandwichError: Error {
  >>     case outOfCleanDishes
  >>     case missingIngredients([String])
  >> }
  >> func washDishes() { print("Wash dishes") }
  >> func buyGroceries(_ shoppingList: [String]) { print("Buy \(shoppingList)") }
  -> func makeASandwich() throws {
         // ...
     }
  >> func eatASandwich() {}

  -> do {
         try makeASandwich()
         eatASandwich()
     } catch SandwichError.outOfCleanDishes {
         washDishes()
     } catch SandwichError.missingIngredients(let ingredients) {
         buyGroceries(ingredients)
     }
  ```
-->

В этом примере функция `makeASandwich()` будет вызывать ошибку, 
если нет чистой посуды или если какие-то ингредиенты отсутствуют. 
Поскольку `makeASandwich()` 
может вызвать ошибку, 
вызов функции обернут в выражение `try`. 
Обернув вызов функции в оператор `do`, 
любые ошибки, которые возникнут, 
будут переданы в предоставленные блоки `catch`.

Если ошибок не возникло, вызывается функция `eatASandwich()`. 
Если произошла ошибка и она соответствует случаю `SandwichError.outOfCleanDishes`, 
то вызывается функция `washDishes()`. 
Если произошла ошибка и она соответствует случаю `SandwichError.missingIngredients`, 
то вызывается функция `buyGroceries(_:)` с ассоциированным значением `[String]`,
полученным сопоставлением с шаблоном `catch`.

Генерация, перехват и передача ошибок подробно описаны 
в разделе <doc:ErrorHandling>.

## Утверждения и предусловия

*Утверждения* и *предусловия* - 
это проверки, выполняемые во время выполнения. 
Вы используете их, чтобы удостовериться, 
что существенное условие выполнено перед выполнением дальнейшего кода. 
Если булево условие в утверждении или 
предусловии оценивается как `true`, 
выполнение кода продолжается как обычно. 
Если условие оценивается как `false`, 
текущее состояние программы недействительно; 
выполнение кода завершается, и ваше приложение завершается.

Вы используете утверждения и предусловия, 
чтобы выражать предположения и ожидания, 
которые у вас есть при написании кода, 
поэтому их можно включать в состав вашего кода. 
Утверждения помогают выявлять ошибки и неверные 
предположения во время разработки, 
а предусловия помогают выявлять проблемы в производстве.

Помимо проверки ожиданий во время выполнения, 
утверждения и предусловия также становятся полезной формой 
документации в коде. 
В отличие от условий ошибок, рассмотренных в разделе выше
<doc:TheBasics#Обработка-ошибок> , утверждения и предусловия не используются для
восстановимых или ожидаемых ошибок. 
Поскольку неудачное утверждение или 
предусловие указывает на недействительное 
состояние программы, нет способа перехватить неудавшееся утверждение. 
Восстановление из недействительного состояния невозможно. 
Когда утверждение не выполняется, 
хотя бы один элемент данных программы является
недействительным, но вы не знаете, 
почему он недействителен или является ли еще какое-то состояние недействительным.

Использование утверждений и предусловия
не заменяет разработку вашего кода таким образом, 
чтобы маловероятно возникновение недопустимых условий.  
Однако 
использование их для обеспечения действительных данных и состояния 
приводит к более предсказуемому завершению вашего приложения, 
если возникает недействительное состояние, 
и помогает упростить отладку проблемы. 
Когда предположения не проверяются, 
вы можете не заметить эту 
проблему до гораздо позднего времени, 
когда код в другом месте начнет вызывать заметные сбои, 
и после того, 
как пользовательские данные будут молча повреждены.

Различие между утверждениями и предусловиями заключается в том, когда они проверяются:
утверждения проверяются только в отладочных сборках, 
а предусловия проверяются как в отладочных, 
так и в продукционных сборках. 
В продукционных сборках условие внутри утверждения не оценивается. 
Это означает, 
что вы можете использовать столько утверждений, сколько хотите, 
в процессе разработки, не влияя на производительность в продакшене.

### Отладка с использованием утверждений

<!--
  Если ваш код вызывает утверждение во время выполнения в отладочной среде,
  например, при построении и запуске приложения в Xcode,
  вы можете точно узнать, где произошло недействительное состояние,
  и проверить состояние вашего приложения в момент срабатывания утверждения.
  Утверждение также позволяет предоставить подходящее отладочное сообщение о характере утверждения.
-->

Утверждение создается с помощью вызова функции
[`assert(_:_:file:line:)`](https://developer.apple.com/documentation/swift/1541112-assert) 
из стандартной библиотеки Swift. 
Вы передаете этой функции выражение, которое оценивается как `true` или `false`,
и сообщение для отображения в случае, если результат условия - `false`. 
Например:

```swift
let age = -3
assert(age >= 0, "Возраст человека не может быть меньше нуля.")
// Это утверждение не выполняется, потому что -3 не >= 0.
```

<!--
  - test: `assertions-1`

  ```swifttest
  -> let age = -3
  -> assert(age >= 0, "Возраст человека не может быть меньше нуля.")
  xx assert
  // Это утверждение не выполняется, потому что -3 не >= 0.
  ```
-->

В этом примере выполнение кода продолжается, если `age >= 0` оценивается как `true`, 
то есть, если значение `age` неотрицательно. 
Если значение `age` отрицательно, как в приведенном выше коде, 
то `age >= 0` оценивается как `false`, 
и утверждение не выполняется, завершая приложение.

Вы можете опустить сообщение утверждения --- 
например, когда оно просто повторяет условие в виде текста.

```swift
assert(age >= 0)
```

<!--
  - test: `assertions-2`

  ```swifttest
  >> let age = -3
  -> assert(age >= 0)
  xx assert
  ```
-->

<!--
  - test: `assertionsCanUseStringInterpolation`

  ```swifttest
  -> let age = -3
  -> assert(age >= 0, "A person's age can't be less than zero, but value is \(age).")
  xx assert
  ```
-->

Если код уже проверяет условие, 
вы используете функцию
[`assertionFailure(_:file:line:)`](https://developer.apple.com/documentation/swift/1539616-assertionfailure), 
чтобы указать, что утверждение не выполнено. 
Например:

```swift
if age > 10 {
    print("Вы можете поехать на американские горки или колесо обозрения.")
} else if age >= 0 {
    print("Вы можете поехать на колесо обозрения.")
} else {
    assertionFailure("Возраст человека не может быть меньше нуля.")
}
```

<!--
  - test: `assertions-3`

  ```swifttest
  >> let age = -3
  -> if age > 10 {
         print("Вы можете поехать на американские горки или колесо обозрения.")
     } else if age >= 0 {
         print("Вы можете поехать на колесо обозрения.")
     } else {
         assertionFailure("Возраст человека не может быть меньше нуля.")
     }
  xx assert
  ```
-->

### Соблюдение предусловий

Используйте предусловие, когда условие может быть ложным, 
но *обязательно* должно быть истинным для продолжения выполнения вашего кода. 
Например, используйте предусловие для проверки того, что индекс не выходит за 
пределы массива, или для проверки того, что функции передано допустимое значение.

Предусловие создается с использованием функции
[`precondition(_:_:file:line:)`](https://developer.apple.com/documentation/swift/1540960-precondition). 
Вы передаете этой функции выражение, которое оценивается как `true` или `false`, 
и сообщение для отображения в случае, если результат условия - `false`. 
Например:

```swift
// В реализации подскрипта...
precondition(index > 0, "Индекс должен быть больше нуля.")
```

<!--
  - test: `preconditions`

  ```swifttest
  >> let index = -1
  // В реализации подскрипта...
  -> precondition(index > 0, "Индекс должен быть больше нуля.")
  xx assert
  ```
-->

Вы также можете вызвать функцию
[`preconditionFailure(_:file:line:)`](https://developer.apple.com/documentation/swift/1539374-preconditionfailure), 
чтобы указать, что произошел сбой --- 
например, если был взят дефолтный случай `switch`, 
но все допустимые входные данные должны были быть 
обработаны одним из других случаев `switch`.

> Примечание: Если вы компилируете в режиме без проверок (`-Ounchecked`), 
> предусловия не проверяются. Компилятор предполагает, 
> что предусловия всегда истинны, 
> и оптимизирует ваш код соответственно. 
> Однако функция `fatalError(_:file:line:)` всегда завершает выполнение, 
> независимо от настроек оптимизации. 

> Вы можете использовать функцию
> `fatalError(_:file:line:)` во время прототипирования и ранней разработки для
> создания заглушек для функциональности, 
> которая еще не реализована, 
> написав `fatalError("Не реализовано")` в качестве заглушки. 
> Поскольку фатальные ошибки никогда не устраняются, 
> в отличие от утверждений или предусловий, вы можете быть уверены, 
> что выполнение всегда прекратится, если встретится заглушка.

<!--
  "\ " в первой ячейке ниже позволяет оставить ее пустой.
  В противном случае RST рассматривает строку как продолжение.

  ============ =====  ==========  ===============================
  \            Debug  Production  Production with ``-Ounchecked``
  ============ =====  ==========  ===============================
  Assertion    Да     Нет         Нет
  ------------ -----  ----------  -------------------------------
  Precondition Да     Да          Нет
  ------------ -----  ----------  -------------------------------
  Fatal Error  Да     Да          Да
  ============ =====  ==========  ===============================
-->

<!--
  TODO: В Xcode можно установить точку останова на сбое утверждения/предусловия?
  Если да, укажите на это и предоставьте ссылку на руководство, которое покажет 
  вам, как это сделать. В LLDB 'breakpoint set -E swift' перехватывает ошибки, 
  но не останавливается на утверждениях.
-->

<!--
Этот исходный файл является частью проекта с открытым исходным кодом Swift.org

Copyright (c) 2014 - 2022 Apple Inc. и авторы проекта Swift
Лицензия Apache License v2.0 с исключением из библиотеки времени выполнения

См. https://swift.org/LICENSE.txt для информации о лицензии
См. https://swift.org/CONTRIBUTORS.txt для списка авторов проекта Swift
-->
