# Основные операторы

Выполняют операции, такие как присваивание, арифметика и сравнение.

*Оператор* - это специальный символ или фраза, 
который вы используете для проверки, изменения или объединения значений.
Например, оператор сложения (`+`) складывает два числа, 
как в `let i = 1 + 2`, 
а логический оператор И (`&&`) объединяет два булевых значения, 
как в `if enteredDoorCode && passedRetinaScan`.

Swift поддерживает операторы, которые вы возможно уже знаете из языков, 
таких как C, и улучшает несколько возможностей для исключения распространенных 
ошибок в коде. Оператор присваивания (`=`) не возвращает значение, 
чтобы предотвратить его ошибочное использование, 
когда предполагается использование оператора равенства (`==`).
Арифметические операторы (`+`, `-`, `*`, `/`, `%` и так далее) обнаруживают и 
запрещают переполнение значений, чтобы избежать неожиданных результатов при 
работе с числами, которые становятся больше или меньше допустимого диапазона 
значений типа, который их хранит.
Вы можете включить поведение переполнения значений, 
используя операторы переполнения Swift, 
как описано в <doc:AdvancedOperators#Overflow-Operators>.

Swift также предоставляет диапазонные операторы, которые отсутствуют в C, 
такие как `a..<b` и `a...b`, 
как сокращение для выражения диапазона значений.

Эта глава описывает общие операторы в Swift.
<doc:AdvancedOperators> рассматривает продвинутые операторы Swift и описывает, 
как определить собственные пользовательские операторы и реализовать стандартные 
операторы для ваших собственных типов.

## Терминология

Операторы бывают унарными, бинарными или тернарными:

- *Унарные* операторы действуют на одну цель (например, `-a`).
  Унарные *префиксные* операторы появляются непосредственно перед своей целью (например, `!b`),
  и унарные *постфиксные* операторы появляются непосредственно после своей цели (например, `c!`).
- *Бинарные* операторы действуют на две цели (например, `2 + 3`)
  и являются *инфиксными*, так как они появляются между двумя своими целями.
- *Тернарные* операторы действуют на три цели.
  Как и в C, в Swift есть только один тернарный оператор,
  тернарный условный оператор (`a ? b : c`).

Значения, которые операторы воздействуют, называются *операндами*.
В выражении `1 + 2` символ `+` является инфиксным оператором,
а его два операнда - это значения `1` и `2`.

## Оператор присваивания

*Оператор присваивания* (`a = b`)
инициализирует или обновляет значение `a` значением `b`:

```swift
let b = 10
var a = 5
a = b
// теперь a равно 10
```

<!--
  - test: `assignmentOperator`

  ```swifttest
  -> let b = 10
  -> var a = 5
  -> a = b
  /> теперь a равно \(a)
  </ теперь a равно 10
  ```
-->

Если справа от оператора присваивания находится кортеж с несколькими значениями,
его элементы можно декомпонировать в несколько констант или переменных сразу:

```swift
let (x, y) = (1, 2)
// x равно 1, а y равно 2
```

<!--
  - test: `assignmentOperator`

  ```swifttest
  -> let (x, y) = (1, 2)
  /> x равно \(x), а y равно \(y)
  </ x равно 1, а y равно 2
  ```
-->

<!--
  - test: `tuple-unwrapping-with-var``

  ```swifttest
  >> var (x, y) = (1, 2)
  ```
-->

<!--
  Это все еще позволяет присваивание переменным,
  даже если образцы var были удалены,
  потому что это интерпретируется как объявление переменной,
  используя первую альтернативу, где (x, y) является образцом,
  но `var` исходит из заголовка объявления переменной,
  а не из образца.
-->

В отличие от оператора присваивания в C и Objective-C,
оператор присваивания в Swift сам по себе не возвращает значение.
Следующее выражение недопустимо:

```swift
if x = y {
    // Это недопустимо, потому что x = y не возвращает значение.
}
```

<!--
  - test: `assignmentOperatorInvalid`

  ```swifttest
  -> if x = y {
        // Это недопустимо, потому что x = y не возвращает значение.
     }
  !$ ошибка: не удается найти 'x' в области видимости
  !! if x = y {
  !!    ^
  !$ ошибка: не удается найти 'y' в области видимости
  !! if x = y {
  !!        ^
  ```
-->

Эта особенность предотвращает случайное использование оператора присваивания (`=`),
когда на самом деле имелось в виду оператор равенства (`==`).
Сделав `if x = y` недопустимым,
Swift помогает вам избежать таких ошибок в вашем коде.

<!--
  TODO: Следует ли упомянуть, что x = y = z также недопустимо?
  Если да, есть ли убедительные аргументы в пользу этого?
-->

## Арифметические операторы

Swift поддерживает четыре стандартных *арифметических оператора* для всех числовых типов:

- Сложение (`+`)
- Вычитание (`-`)
- Умножение (`*`)
- Деление (`/`)

```swift
1 + 2       // равно 3
5 - 3       // равно 2
2 * 3       // равно 6
10.0 / 2.5  // равно 4.0
```

<!--
  - test: `arithmeticOperators`

  ```swifttest
  >> let r0 =
  -> 1 + 2       // равно 3
  >> assert(r0 == 3)
  >> let r1 =
  -> 5 - 3       // равно 2
  >> assert(r1 == 2)
  >> let r2 =
  -> 2 * 3       // равно 6
  >> assert(r2 == 6)
  >> let r3 =
  -> 10.0 / 2.5  // равно 4.0
  >> assert(r3 == 4.0)
  ```
-->

В отличие от арифметических операторов в C и Objective-C,
в Swift арифметические операторы по умолчанию не позволяют значениям переполняться.
Вы можете включить поведение переполнения значения, используя операторы переполнения Swift
(например, `a &+ b`). Смотрите <doc:AdvancedOperators#Overflow-Operators>.

Оператор сложения также поддерживается для конкатенации `String`:

```swift
"hello, " + "world"  // равно "hello, world"
```

<!--
  - test: `arithmeticOperators`

  ```swifttest
  >> let r4 =
  -> "hello, " + "world"  // равно "hello, world"
  >> assert(r4 == "hello, world")
  ```
-->

### Оператор остатка от деления

Оператор *остатка от деления* (`a % b`)
определяет, сколько крат числа `b` поместится в `a`,
и возвращает оставшееся значение
(называемое *остатком*).

> Примечание: Оператор остатка от деления (`%`) также известен как
> *оператор модуля* в других языках программирования.
> Однако его поведение в Swift для отрицательных чисел означает,
> что строго говоря, это не операция модуля, а операция остатка.

<!--
  - test: `percentOperatorIsRemainderNotModulo`

  ```swifttest
  -> for i in -5...0 {
        print(i % 4)
     }
  << -1
  << 0
  << -3
  << -2
  << -1
  << 0
  ```
-->

Вот как работает оператор остатка от деления.
Чтобы вычислить `9 % 4`, сначала определите, сколько `4` поместится в `9`:

![](remainderInteger)

В `9` помещаются две `4`, а остаток равен `1` (показан оранжевым цветом).

В Swift это будет выглядеть так:

```swift
9 % 4    // равно 1
```

<!--
  - test: `arithmeticOperators`

  ```swifttest
  >> let r5 =
  -> 9 % 4    // равно 1
  >> assert(r5 == 1)
  ```
-->

Для определения ответа для `a % b`,
оператор `%` вычисляет следующее уравнение
и возвращает `остаток` в качестве вывода:

`a` = (`b` x `некоторое множительное число`) + `остаток`

где `некоторое множительное число` - это наибольшее количество крат числа `b`,
которое поместится в `a`.

Подставив `9` и `4` в это уравнение, получим:

`9` = (`4` x `2`) + `1`

Тот же метод применяется при вычислении остатка для отрицательного значения `a`:

```swift
-9 % 4   // равно -1
```

<!--
  - test: `arithmeticOperators`

  ```swifttest
  >> let r6 =
  -> -9 % 4   // равно -1
  >> assert(r6 == -1)
  ```
-->

Подставив `-9` и `4` в уравнение, получим:

`-9` = (`4` x `-2`) + `-1`

что дает значение остатка `-1`.

Знак `b` игнорируется для отрицательных значений `b`.
Это означает, что `a % b` и `a % -b` всегда дают одинаковый ответ.

### Оператор унарного минуса

Знак числового значения можно изменить с помощью префиксного `-`,
известного как *оператор унарного минуса*:

```swift
let three = 3
let minusThree = -three       // minusThree равно -3
let plusThree = -minusThree   // plusThree равно 3, или "минус минус три"
```

<!--
  - test: `arithmeticOperators`

  ```swifttest
  -> let three = 3
  -> let minusThree = -three       // minusThree равно -3
  -> let plusThree = -minusThree   // plusThree равно 3, или "минус минус три"
  ```
-->

Оператор унарного минуса (`-`) добавляется прямо перед значением, на котором он 
действует, без каких-либо пробелов.

### Оператор унарного плюса

*Оператор унарного плюса* (`+`) просто возвращает
значение, на котором он действует, без изменений:

```swift
let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix равно -6
```

<!--
  - test: `arithmeticOperators`

  ```swifttest
  -> let minusSix = -6
  -> let alsoMinusSix = +minusSix  // alsoMinusSix равно -6
  >> assert(alsoMinusSix == minusSix)
  ```
-->

Хотя оператор унарного плюса на самом деле ничего не делает,
его можно использовать для симметрии в вашем коде для положительных чисел,
когда также используется оператор унарного минуса для отрицательных чисел.

## Операторы составного присваивания

Как и в C, Swift предоставляет *операторы составного присваивания*, которые объединяют присваивание (`=`) с другой операцией.
Один из примеров - *оператор сложения с присваиванием* (`+=`):

```swift
var a = 1
a += 2
// a теперь равно 3
```

<!--
  - test: `compoundAssignment`

  ```swifttest
  -> var a = 1
  -> a += 2
  /> a теперь равно \(a)
  </ a теперь равно 3
  ```
-->

Выражение `a += 2` является сокращением для `a = a + 2`.
Эффективно сложение и присваивание объединены в один оператор,
который выполняет обе задачи одновременно.

> Примечание: Операторы составного присваивания не возвращают значение.
> Например, вы не можете написать `let b = a += 2`.

Для получения информации об операторах, предоставляемых стандартной библиотекой Swift,
смотрите [Объявления операторов](https://developer.apple.com/documentation/swift/operator_declarations).

## Операторы сравнения

Swift поддерживает следующие операторы сравнения:

- Равно (`a == b`)
- Не равно (`a != b`)
- Больше (`a > b`)
- Меньше (`a < b`)
- Больше или равно (`a >= b`)
- Меньше или равно (`a <= b`)

> Примечание: Swift также предоставляет два *оператора идентичности* (`===` и `!==`),
> которые вы используете для проверки, ссылаются ли две ссылки на объект на один и тот же объект.
> Для получения дополнительной информации смотрите <doc:ClassesAndStructures#Identity-Operators>.

Каждый из операторов сравнения возвращает значение `Bool`, чтобы указать, истинно ли утверждение:

```swift
1 == 1   // true, потому что 1 равно 1
2 != 1   // true, потому что 2 не равно 1
2 > 1    // true, потому что 2 больше 1
1 < 2    // true, потому что 1 меньше 2
1 >= 1   // true, потому что 1 больше или равно 1
2 <= 1   // false, потому что 2 меньше или равно 1
```

<!--
  - test: `comparisonOperators`

  ```swifttest
  >> assert(
  -> 1 == 1   // true, потому что 1 равно 1
  >> )
  >> assert(
  -> 2 != 1   // true, потому что 2 не равно 1
  >> )
  >> assert(
  -> 2 > 1    // true, потому что 2 больше 1
  >> )
  >> assert(
  -> 1 < 2    // true, потому что 1 меньше 2
  >> )
  >> assert(
  -> 1 >= 1   // true, потому что 1 больше или равно 1
  >> )
  >> assert( !(
  -> 2 <= 1   // false, потому что 2 меньше или равно 1
  >> ) )
  ```
-->

Операторы сравнения часто используются в условных операторах,
таких как оператор `if`:

```swift
let name = "world"
if name == "world" {
    print("hello, world")
} else {
    print("I'm sorry \(name), but I don't recognize you")
}
// Выводит "hello, world", потому что name действительно равно "world".
```

<!--
  - test: `comparisonOperators`

  ```swifttest
  -> let name = "world"
  -> if name == "world" {
        print("hello, world")
     } else {
        print("I'm sorry \(name), but I don't recognize you")
     }
  << hello, world
  // Выводит "hello, world", потому что name действительно равно "world".
  ```
-->

Для получения дополнительной информации о операторе `if`, смотрите <doc:ControlFlow>.

Два кортежа можно сравнивать,
если они имеют одинаковый тип и одинаковое количество значений.
Сравнение кортежей происходит слева направо,
по одному значению за раз,
пока сравнение не найдет два значения,
которые не равны.
Эти два значения сравниваются,
и результат этого сравнения
определяет общий результат сравнения кортежа.
Если все элементы равны,
то кортежи сами по себе равны.
Например:

```swift
(1, "zebra") < (2, "apple")   // true, потому что 1 меньше 2; "zebra" и "apple" не сравниваются
(3, "apple") < (3, "bird")    // true, потому что 3 равно 3, и "apple" меньше "bird"
(4, "dog") == (4, "dog")      // true, потому что 4 равно 4, и "dog" равно "dog"
```

<!--
  - test: `tuple-comparison-operators`

  ```swifttest
  >> let a =
  -> (1, "zebra") < (2, "apple")   // true потому что 1 меньше 2; "zebra" и "apple" не сравниваются
  >> let b =
  -> (3, "apple") < (3, "bird")    // true потому что 3 равно 3, и "apple" меньше "bird"
  >> let c =
  -> (4, "dog") == (4, "dog")      // true потому что 4 равно 4, и "dog" равно "dog"
  >> print(a, b, c)
  << true true true
  ```
-->

В приведенном выше примере
можно увидеть поведение сравнения слева направо на первой строке.
Так как `1` меньше `2`,
`(1, "zebra")` считается меньше `(2, "apple")`,
независимо от любых других значений в кортежах.
Не имеет значения, что `"zebra"` не меньше `"apple"`,
потому что сравнение уже определено по первым элементам кортежей.
Однако,
когда первые элементы кортежей равны,
их вторые элементы *сравниваются* ---
это происходит на второй и третьей строке.

Кортежи можно сравнивать с заданным оператором только в том случае,
если оператор может быть применен к каждому значению в соответствующих кортежах. Например,
как показано в приведенном ниже коде, вы можете сравнивать
два кортежа типа `(String, Int)` потому что
и `String`, и `Int` значения могут быть сравнены
с использованием оператора `<`. В отличие от этого,
два кортежа типа `(String, Bool)` не могут быть сравнены
с использованием оператора `<`, потому что оператор `<` не может быть применен к
значениям `Bool`.

```swift
("blue", -1) < ("purple", 1)        // ОК, вычисляется как true
("blue", false) < ("purple", true)  // Ошибка, так как < не может сравнить значения типа Boolean
```

<!--
  - test: `tuple-comparison-operators-err`

  ```swifttest
  >> _ =
  -> ("blue", -1) < ("purple", 1)        // ОК, вычисляется как true
  >> _ =
  -> ("blue", false) < ("purple", true)  // Ошибка, так как < не может сравнить значения типа Boolean
  !$ ошибка: тип '(String, Bool)' не может соответствовать 'Comparable'
  !! ("blue", false) < ("purple", true)  // Ошибка, так как < не может сравнить значения типа Boolean
  !!                 ^
  !$ заметка: только конкретные типы, такие как структуры, перечисления и классы, могут соответствовать протоколам
  !! ("blue", false) < ("purple", true)  // Ошибка, так как < не может сравнить значения типа Boolean
  !!                 ^
  !$ заметка: требуется для оператора '<' на 'Comparable' где 'Self' = '(String, Bool)'
  !! ("blue", false) < ("purple", true)  // Ошибка, так как < не может сравнить значения типа Boolean
  !!                 ^
  ```
-->

<!--
  - test: `tuple-comparison-operators-ok`

  ```swifttest
  >> let x = ("blue", -1) < ("purple", 1)        // ОК, вычисляется как true
  >> print(x)
  << true
  ```
-->

> Примечание: Стандартная библиотека Swift включает операторы сравнения для кортежей
> с менее чем семью элементами.
> Для сравнения кортежей с семью или более элементами
> вам необходимо реализовать операторы сравнения самостоятельно.

<!--
  TODO: на каких типах они работают по умолчанию?
  Как они работают со строками?
  А как с вашими собственными типами?
-->

## Тернарный условный оператор

*Тернарный условный оператор* — это специальный оператор с тремя частями,
который имеет форму `вопрос ? ответ1 : ответ2`.
Это сокращение для вычисления одного из двух выражений
на основе того, истинен ли `вопрос` или нет.
Если `вопрос` истинен, он вычисляет `ответ1` и возвращает его значение;
в противном случае он вычисляет `ответ2` и возвращает его значение.

Тернарный условный оператор является сокращением для следующего кода:

```swift
if question {
    answer1
} else {
    answer2
}
```

<!--
  - test: `ternaryConditionalOperatorOutline`

  ```swifttest
  >> let question = true
  >> let answer1 = true
  >> let answer2 = true
  -> if question {
        answer1
     } else {
        answer2
     }
  !! /tmp/swifttest.swift:5:4: warning: expression of type 'Bool' is unused
  !! answer1
  !! ^~~~~~~
  !! /tmp/swifttest.swift:7:4: warning: expression of type 'Bool' is unused
  !! answer2
  !! ^~~~~~~
  ```
-->

<!--
  FIXME Этот пример слишком абстрактный.
  В Swift нет выражений 'if'.
-->

Вот пример, который вычисляет высоту строки таблицы.
Высота строки должна быть на 50 точек выше высоты содержимого,
если у строки есть заголовок, и на 20 точек выше, если у строки нет заголовка:

```swift
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
// rowHeight равна 90
```

<!--
  - test: `ternaryConditionalOperatorPart1`

  ```swifttest
  -> let contentHeight = 40
  -> let hasHeader = true
  -> let rowHeight = contentHeight + (hasHeader ? 50 : 20)
  /> rowHeight равна \(rowHeight)
  </ rowHeight равна 90
  ```
-->

Приведенный выше пример является сокращением для следующего кода:

```swift
let contentHeight = 40
let hasHeader = true
let rowHeight: Int
if hasHeader {
    rowHeight = contentHeight + 50
} else {
    rowHeight = contentHeight + 20
}
// rowHeight равна 90
```

<!--
  - test: `ternaryConditionalOperatorPart2`

  ```swifttest
  -> let contentHeight = 40
  -> let hasHeader = true
  -> let rowHeight: Int
  -> if hasHeader {
        rowHeight = contentHeight + 50
     } else {
        rowHeight = contentHeight + 20
     }
  /> rowHeight равна \(высотаСтроки)
  </ rowHeight равна 90
  ```
-->

Использование тернарного условного оператора в первом примере позволяет
установить значение `rowHeight` корректно в одной строке кода,
что более лаконично, чем код, использованный во втором примере.

Тернарный условный оператор предоставляет
эффективное сокращение для принятия решения о том, какое из двух выражений рассматривать.
Однако используйте тернарный условный оператор осторожно.
Его краткость может привести к трудночитаемому коду при чрезмерном использовании.
Избегайте комбинирования нескольких экземпляров тернарного условного оператора в одном составном операторе.

## Оператор объединения по нулевому значению

*Оператор объединения по нулевому значению* (`a ?? b`)
раскрывает опциональное значение `a`, если оно содержит значение,
или возвращает значение по умолчанию `b`, если `a` равно `nil`.
Выражение `a` всегда имеет опциональный тип.
Выражение `b` должно соответствовать типу, который хранится внутри `a`.

Оператор объединения по нулевому значению является сокращением для следующего кода:

```swift
a != nil ? a! : b
```

<!--
  - test: `nilCoalescingOperatorOutline`

  ```swifttest
  >> var a: Int?
  >> let b = 42
  >> let c =
  -> a != nil ? a! : b
  >> print(c)
  << 42
  ```
-->

Приведенный выше код использует тернарный условный оператор и принудительное извлечение значения (`a!`)
для доступа к значению, обернутому внутри `a`, когда `a` не равно `nil`,
и возвращает `b` в противном случае.
Оператор объединения по нулевому значению предоставляет более элегантный способ инкапсуляции
этой условной проверки и извлечения в лаконичной и читаемой форме.

> Примечание: Если значение `a` не равно `nil`,
> значение `b` не вычисляется.
> Это известно как *краткое вычисление*.

Приведенный ниже пример использует оператор объединения по нулевому значению для выбора между
именем цвета по умолчанию и опциональным пользовательским именем цвета:

```swift
let defaultColorName = "red"
var userDefinedColorName: String?   // по умолчанию равно nil

var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName равно nil, поэтому colorNameToUse устанавливается в значение по умолчанию "red"
```

<!--
  - test: `nilCoalescingOperator`

  ```swifttest
  -> let defaultColorName = "red"
  -> var userDefinedColorName: String?   // по умолчанию равно nil
  ---
  -> var colorNameToUse = userDefinedColorName ?? defaultColorName
  /> userDefinedColorName равно nil, поэтому colorNameToUse устанавливается в значение по умолчанию \"\(colorNameToUse)\"
  </ userDefinedColorName равно nil, поэтому colorNameToUse устанавливается в значение по умолчанию "red"
  ```
-->

Переменная `userDefinedColorName` определена как опциональный `String`,
с значением по умолчанию `nil`.
Так как `userDefinedColorName` имеет опциональный тип,
вы можете использовать оператор объединения по нулевому значению для рассмотрения его значения.
В приведенном выше примере оператор используется для определения
начального значения для переменной `String` с именем `colorNameToUse`.
Так как `userDefinedColorName` равно `nil`,
выражение `userDefinedColorName ?? defaultColorName` возвращает
значение `defaultColorName`, или `"red"`.

Если вы присвоите `userDefinedColorName` значение, отличное от `nil`,
и снова выполните проверку с оператором объединения по нулевому значению,
будет использовано значение, обернутое внутри `userDefinedColorName`, вместо значения по умолчанию:

```swift
userDefinedColorName = "green"
colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName не равно nil, поэтому colorNameToUse устанавливается в "green"
```

<!--
  - test: `nilCoalescingOperator`

  ```swifttest
  -> userDefinedColorName = "green"
  -> colorNameToUse = userDefinedColorName ?? defaultColorName
  /> userDefinedColorName не равно nil, поэтому colorNameToUse устанавливается в \"\(colorNameToUse)\"
  </ userDefinedColorName не равно nil, поэтому colorNameToUse устанавливается в "green"
  ```
-->

## Операторы диапазона

Swift включает в себя несколько *операторов диапазона*,
которые представляют собой сокращения для выражения диапазона значений.

### Оператор закрытого диапазона

*Оператор закрытого диапазона* (`a...b`)
определяет диапазон, который простирается от `a` до `b`,
включая значения `a` и `b`.
Значение `a` не должно быть больше `b`.

<!--
  - test: `closedRangeStartCanBeLessThanEnd`

  ```swifttest
  -> let range = 1...2
  >> print(type(of: range))
  << ClosedRange<Int>
  ```
-->

<!--
  - test: `closedRangeStartCanBeTheSameAsEnd`

  ```swifttest
  -> let range = 1...1
  ```
-->

<!--
  - test: `closedRangeStartCannotBeGreaterThanEnd`

  ```swifttest
  -> let range = 1...0
  xx assertion
  ```
-->

Оператор закрытого диапазона полезен при итерации по диапазону,
в котором вы хотите использовать все значения,
например, с помощью цикла `for`-`in`:

```swift
for index in 1...5 {
    print("\(index) умножить на 5 равно \(index * 5)")
}
// 1 умножить на 5 равно 5
// 2 умножить на 5 равно 10
// 3 умножить на 5 равно 15
// 4 умножить на 5 равно 20
// 5 умножить на 5 равно 25
```

<!--
  - test: `rangeOperators`

  ```swifttest
  -> for index in 1...5 {
        print("\(index) умножить на 5 равно \(index * 5)")
     }
  </ 1 умножить на 5 равно 5
  </ 2 умножить на 5 равно 10
  </ 3 умножить на 5 равно 15
  </ 4 умножить на 5 равно 20
  </ 5 умножить на 5 равно 25
  ```
-->

Для получения дополнительной информации о циклах `for`-`in`, см. <doc:ControlFlow>.

### Оператор полузакрытого диапазона

*Оператор полузакрытого диапазона* (`a..<b`)
определяет диапазон, который простирается от `a` до `b`,
но не включает `b`.
Он называется *полузакрытым*,
потому что он содержит свое первое значение, но не его последнее значение.
Как и с оператором закрытого диапазона,
значение `a` не должно быть больше `b`.
Если значение `a` равно `b`,
то результатирующий диапазон будет пустым.

<!--
  - test: `halfOpenRangeStartCanBeLessThanEnd`

  ```swifttest
  -> let range = 1..<2
  >> print(type(of: range))
  << Range<Int>
  ```
-->

<!--
  - test: `halfOpenRangeStartCanBeTheSameAsEnd`

  ```swifttest
  -> let range = 1..<1
  ```
-->

<!--
  - test: `halfOpenRangeStartCannotBeGreaterThanEnd`

  ```swifttest
  -> let range = 1..<0
  xx assertion
  ```
-->

Оператор полузакрытого диапазона особенно полезен при работе с
списками, начинающимися с нуля, такими как массивы,
где полезно считать до (но не включая) длину списка:

```swift
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count {
    print("Person \(i + 1) is called \(names[i])")
}
// Person 1 is called Anna
// Person 2 is called Alex
// Person 3 is called Brian
// Person 4 is called Jack
```

<!--
  - test: `rangeOperators`

  ```swifttest
  -> let names = ["Anna", "Alex", "Brian", "Jack"]
  -> let count = names.count
  >> assert(count == 4)
  -> for i in 0..<count {
        print("Person \(i + 1) is called \(names[i])")
     }
  </ Person 1 is called Anna
  </ Person 2 is called Alex
  </ Person 3 is called Brian
  </ Person 4 is called Jack
  ```
-->

Обратите внимание, что массив содержит четыре элемента,
но `0..<count` считает только до `3`
(индекс последнего элемента в массиве),
потому что это полузакрытый диапазон.
Для получения дополнительной информации о массивах, см. <doc:CollectionTypes#Arrays>.

### Односторонние диапазоны

Оператор закрытого диапазона
имеет альтернативную форму для диапазонов, которые продолжаются
насколько возможно в одном направлении ---
например, 
диапазон, который включает все элементы массива
от индекса 2 до конца массива.
В этих случаях вы можете опустить значение
с одной стороны оператора диапазона.
Этот тип диапазона называется *односторонним диапазоном*
потому что оператор имеет значение только с одной стороны.
Например:

```swift
for name in names[2...] {
    print(name)
}
// Brian
// Jack

for name in names[...2] {
    print(name)
}
// Anna
// Alex
// Brian
```

<!--
  - test: `rangeOperators`

  ```swifttest
  -> for name in names[2...] {
         print(name)
     }
  </ Brian
  </ Jack
  ---
  -> for name in names[...2] {
         print(name)
     }
  </ Anna
  </ Alex
  </ Brian
  ```
-->

Оператор полузакрытого диапазона также имеет
одностороннюю форму, которая записывается
только с его конечным значением.
Как и при включении значения с обеих сторон,
конечное значение не является частью диапазона.
Например:

```swift
for name in names[..<2] {
    print(name)
}
// Anna
// Alex
```

<!--
  - test: `rangeOperators`

  ```swifttest
  -> for name in names[..<2] {
         print(name)
     }
  </ Anna
  </ Alex
  ```
-->

Односторонние диапазоны можно использовать и в других контекстах,
а не только в подсценариях.
Вы не можете итерироваться по одностороннему диапазону,
который опускает первое значение,
поскольку неясно, с какого места начать итерацию.
Вы *можете* итерироваться по одностороннему диапазону, который опускает его конечное значение;
однако, поскольку диапазон продолжается бесконечно,
убедитесь, что вы добавили явное условие завершения цикла.
Также можно проверить, содержит ли односторонний диапазон определенное значение,
как показано в приведенном ниже коде.

```swift
let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true
```

<!--
  - test: `rangeOperators`

  ```swifttest
  -> let range = ...5
  >> print(type(of: range))
  << PartialRangeThrough<Int>
  >> let a =
  -> range.contains(7)   // false
  >> let b =
  -> range.contains(4)   // true
  >> let c =
  -> range.contains(-1)  // true
  >> print(a, b, c)
  << false true true
  ```
-->

## Логические операторы

*Логические операторы* модифицируют или объединяют
логические значения `true` и `false`.
Swift поддерживает три стандартных логических оператора, которые можно найти в языках на основе C:

- Логическое НЕ (`!a`)
- Логическое И (`a && b`)
- Логическое ИЛИ (`a || b`)

### Оператор логического НЕ

*Оператор логического НЕ* (`!a`) инвертирует логическое значение так, что `true` становится `false`,
а `false` становится `true`.

Оператор логического НЕ является префиксным оператором,
и появляется непосредственно перед значением, на котором он действует,
без каких-либо пробелов.
Он может быть прочитан как “не `a`”, как показано в следующем примере:

```swift
let allowedEntry = false
if !allowedEntry {
    print("ACCESS DENIED")
}
// Вывод: "ACCESS DENIED"
```

<!--
  - test: `logicalOperators`

  ```swifttest
  -> let allowedEntry = false
  -> if !allowedEntry {
        print("ACCESS DENIED")
     }
  <- ACCESS DENIED
  ```
-->

Фразу `if !allowedEntry` можно прочитать как “если не разрешен вход”.
Последующая строка выполняется только если “не разрешен вход” истинен;
то есть, если `allowedEntry` является `false`.

Как и в этом примере,
тщательный выбор имен логических констант и переменных
может помочь сохранить код читаемым и лаконичным,
избегая двойных отрицаний или запутанных логических выражений.

### Оператор логического И

*Оператор логического И* (`a && b`) создает логические выражения,
где оба значения должны быть `true`, чтобы итоговое выражение также было `true`.

Если хотя бы одно значение является `false`,
итоговое выражение также будет `false`.
Фактически, если *первое* значение `false`,
второе значение даже не будет вычислено,
поскольку оно не может сделать итоговое выражение равным `true`.
Это известно как *краткозамкнутая оценка*.

Этот пример рассматривает два значения типа `Bool`
и разрешает доступ только в том случае, если оба значения являются `true`:

```swift
let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaScan {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Вывод: "ACCESS DENIED"
```

<!--
  - test: `logicalOperators`

  ```swifttest
  -> let enteredDoorCode = true
  -> let passedRetinaScan = false
  -> if enteredDoorCode && passedRetinaScan {
        print("Welcome!")
     } else {
        print("ACCESS DENIED")
     }
  <- ACCESS DENIED
  ```
-->

### Оператор логического ИЛИ

*Оператор логического ИЛИ*
(`a || b`) — это инфиксный оператор, состоящий из двух соседних вертикальных черт.
Вы используете его для создания логических выражений, в которых
только *одно* из двух значений должно быть `true`,
чтобы итоговое выражение было `true`.

Как и оператор логического И выше,
оператор логического ИЛИ использует краткозамкнутую оценку для вычисления своих выражений.
Если левая сторона выражения логического ИЛИ равна `true`,
правая сторона не вычисляется,
поскольку она не может изменить результат итогового выражения.

В приведенном ниже примере
первое значение типа `Bool` (`hasDoorKey`) равно `false`,
но второе значение (`knowsOverridePassword`) равно `true`.
Поскольку одно значение равно `true`,
итоговое выражение также оценивается как `true`,
и доступ разрешен:

```swift
let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Вывод: "Welcome!"
```

<!--
  - test: `logicalOperators`

  ```swifttest
  -> let hasDoorKey = false
  -> let knowsOverridePassword = true
  -> if hasDoorKey || knowsOverridePassword {
        print("Welcome!")
     } else {
        print("ACCESS DENIED")
     }
  <- Welcome!
  ```
-->

### Комбинирование логических операторов

Вы можете комбинировать несколько логических операторов для создания более сложных составных выражений:

```swift
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Вывод: "Welcome!"
```

<!--
  - test: `logicalOperators`

  ```swifttest
  -> if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
        print("Welcome!")
     } else {
        print("ACCESS DENIED")
     }
  <- Welcome!
  ```
-->

В этом примере используются несколько операторов `&&` и `||` для создания более сложного составного выражения.
Однако `&&` и `||` оперируют только двумя значениями,
так что это на самом деле три меньших выражения, объединенных вместе.
Пример можно прочитать как:

Если мы ввели правильный код двери и прошли ретиновое сканирование,
или если у нас есть действующий ключ от двери,
или если мы знаем аварийный код доступа,
то разрешить доступ.

На основе значений `enteredDoorCode`, `passedRetinaScan` и `hasDoorKey`,
первые два подвыражения являются `false`.
Однако аварийный код доступа известен,
поэтому составное выражение все равно оценивается как `true`.

> Примечание: Логические операторы Swift `&&` и `||` ассоциативны слева направо,
> что означает, что составные выражения с несколькими логическими операторами
> оценивают левое подвыражение первым.

### Явные скобки

Иногда полезно добавить скобки там, где они не строго необходимы,
чтобы улучшить читаемость сложного выражения.
В приведенном выше примере доступа к двери
полезно добавить скобки вокруг первой части составного выражения,
чтобы сделать его намерение явным:

```swift
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Вывод: "Welcome!"
```

<!--
  - test: `logicalOperators`

  ```swifttest
  -> if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
        print("Welcome!")
     } else {
        print("ACCESS DENIED")
     }
  <- Welcome!
  ```
-->

Скобки делают очевидным, что первые два значения
рассматриваются как часть отдельного возможного состояния в общей логике.
Вывод составного выражения не изменяется,
но общее намерение становится более ясным для читателя.
Читаемость всегда предпочтительнее краткости;
используйте скобки там, где они помогают сделать ваши намерения понятными.

<!--
Этот исходный файл является частью открытого проекта Swift.org

Авторские права (c) 2014 - 2022 Apple Inc. и авторы проекта Swift
Лицензировано по Apache License v2.0 с исключением из библиотеки времени выполнения

См. https://swift.org/LICENSE.txt для информации о лицензии
См. https://swift.org/CONTRIBUTORS.txt для списка авторов проекта Swift
-->
